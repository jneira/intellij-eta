apply plugin: 'eta'

task runJFlex(type: Exec) {
  commandLine '../tools/run-jflex'
}

task cleanJFlex(type: Exec) {
  commandLine '../tools/run-jflex', 'clean'
}

dependencies {
  compile project(':core')
  compile project(':eta-parser')
  compile project(':jps-shared')
  compile project(':jps-plugin')
  compile eta('base:[4.8,4.9[')
  compile eta('containers:0.5.10.+')
  compile eta('eta-java-interop:0.1.3.+')
}

compileJava.dependsOn(runJFlex)

[compileEta, compileTestEta].each {
  it.options {
    args = ['-Werror','-Wall','-fno-warn-orphans',
            '-fno-warn-missing-signatures','-fno-warn-unused-binds']
    extensions {
      DataKinds
      ExistentialQuantification
      FlexibleContexts
      FlexibleInstances
      FunctionalDependencies
      GeneralizedNewtypeDeriving
      LambdaCase
      MagicHash
      MultiParamTypeClasses
      NoImplicitPrelude
      OverloadedStrings
      RankNTypes
      RecordWildCards
      ScopedTypeVariables
      TypeFamilies
      TypeOperators
      UnboxedTuples
    }
  }
}

clean.dependsOn(cleanJFlex)

prepareSandbox.dependsOn(compileEta)

static def getSandboxLibDir(Project project, Boolean test) {
  def pluginsDir = test ? "plugins-test" : "plugins"
  "${project.intellij.sandboxDirectory}/$pluginsDir/${project.intellij.pluginName}/lib/"
}

// Export our expected core version so we can validate it at runtime.
task genIntelliJEtaMeta {
  doLast {
    def pkgDir = "build/generated-src/java/com/typelead/intellij/plugin/eta"
    mkdir(pkgDir)
    def f = file("$pkgDir/IntelliJEtaMeta.java")
    f.write("""
      package com.typelead.intellij.plugin.eta;

      public interface IntelliJEtaMeta {
        String CORE_VERSION = \"${project(':core').version}\";
      }
    """.stripIndent().trim())
  }
}

compileJava.dependsOn(genIntelliJEtaMeta)

sourceSets.main.java.srcDirs 'src/main/java', 'build/generated-src/java'
