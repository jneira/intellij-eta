import com.typelead.gradle.utils.EtaRuntimeUtils

// Depend on local gradle-eta plugin.
buildscript {
  repositories {
    mavenLocal()

    dependencies {
      classpath 'com.typelead:gradle-eta:0.0.1-SNAPSHOT-f84f682'
    }
  }
}

plugins {
  id "org.jetbrains.intellij" version "0.2.17"
}

group 'com.typelead'

apply plugin: 'java'
apply plugin: 'eta'
apply plugin: 'org.jetbrains.intellij'

ext {
  javaVersion = '1.8'
}

intellij {
  version = '2017.3'
  pluginName = 'IntelliJ-Eta'
  // Makes it easy to support multiple intellij versions.
  // If we want to set this to true, we should find a way to cross build
  // against multiple intellij versions.
  updateSinceUntilBuild = false
  instrumentCode = false
}

eta {
  useSystemEtlas = true
}

sourceCompatibility = 1.8

repositories {
  mavenCentral()
}

dependencies {
}

task hpack(type: Exec) {
  commandLine 'hpack'
}

sandboxAddSourcesEta {
  sources = ['eta-parser']
  inputs.property('etlas_add_source', sources)
  outputs.files('.cabal-sandbox/add-source-timestamps')
}

task makeEtaParserSources(type: Exec) {
  workingDir file('eta-parser')
  commandLine = ['make', 'sources']
  ['eta', 'java', 'patches', 'tools'].each { inputs.dir("eta-parser/$it") }
  ['eta-parser.cabal', 'Makefile'].each { inputs.file("eta-parser/$it") }
}

installDepsEta.dependsOn(hpack, makeEtaParserSources)

[installDepsEta,installTestDepsEta].forEach {
  it.inputs.files('package.yaml')
  it.outputs.dir('.cabal-sandbox/lib')
}

compileEta {
  inputs.dir('src/main/eta')
  outputs.files('build/etlas/dist/build/HSintellij-eta*.jar')
}

testCompileEta {
  inputs.files('src/test/eta')
  outputs.files('build/etlas/dist/build/test/test.jar')
}

prepareSandbox {
  doLast {
    copyEtaRuntimeToPluginSandbox(false)
  }
}

prepareSandbox.dependsOn(compileEta)

prepareTestingSandbox {
  doLast {
    copyEtaRuntimeToPluginSandbox(true)
  }
}

prepareTestingSandbox.dependsOn(testCompileEta)

def getSandboxLibDir(Boolean test) {
  def pluginsDir = test ? "plugins-test" : "plugins"
  "${intellij.sandboxDirectory}/$pluginsDir/${intellij.pluginName}/lib/"
}

Set<File> getEtaRuntimeClasspath() {
  if (eta.etlasBinary == null) {
    throw new GradleException(
      "Cannot getEtaRuntimeClasspath, eta.etlasBinary is null; "
      + "consider running in a doLast { .. } block instead."
    )
  }
  def component = "lib:intellij-eta"
  // Attempt at caching the runtime, later we can build this into gradle-eta (using ~/.gradle/caches)
  def useCache = true
  if (useCache) {
    File cachedRuntimeFile = new File("build/etlas/runtime/$component")
    if (!cachedRuntimeFile.exists()
      || cachedRuntimeFile.lastModified() < new File('package.yaml').lastModified()) {
      if (cachedRuntimeFile.exists()) {
        cachedRuntimeFile.write('')
      } else {
        cachedRuntimeFile.getParentFile().mkdirs()
      }
      logger.info("Requesting eta runtime classpath...")
      def res = EtaRuntimeUtils.getRuntimeClasspath(project, eta, component)
      logger.info("Using eta runtime classpath: $res")
      res.each { cachedRuntimeFile.append(it.path + '\n') }
      res
    } else {
      Set<File> res = new HashSet<File>()
      //noinspection GroovyMissingReturnStatement
      cachedRuntimeFile.eachLine {
        if (!it.isEmpty()) res.add(new File(it))
      }
      logger.info("Using cached eta runtime classpath: $res")
      res
    }
  } else {
    def res = EtaRuntimeUtils.getRuntimeClasspath(project, eta, component)
    logger.info("Using eta runtime classpath: $res")
    res
  }
}

def copyEtaRuntimeToPluginSandbox(Boolean test) {
  def dest = getSandboxLibDir(test)
  getEtaRuntimeClasspath().forEach { dep ->
    project.copy {
      from dep.canonicalPath
      into dest
    }
  }
}

// Hack to trick junit into thinking we have java tests.
testClasses {
  dependsOn testCompileEta
  doLast {
    copy {
      from zipTree("build/etlas/dist/build/test/test.jar")
      into "build/classes/test"
    }
  }
}

task configureTest {
  dependsOn testCompileEta
  doLast {
    test.classpath += files(getEtaRuntimeClasspath())
  }
}

test {
  dependsOn configureTest
}
